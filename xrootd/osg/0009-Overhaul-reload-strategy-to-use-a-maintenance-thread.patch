From 0d72b74fbe142b163dff44a31482487f8429d81c Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 10:18:03 -0600
Subject: [PATCH 09/17] Overhaul reload strategy to use a maintenance thread.

Instead of doing the reload of the mapfile in-line, add a new maintenance
thread that will periodically reload the mapfile (if and only if a change
is detected in the modification time of the mapfile).

(cherry picked from commit 29fa30a2271a45b4a4cead5ba78686c767ede3d2)
---
 src/XrdVoms/XrdVomsMapfile.cc | 150 +++++++++++++++++++++++++++++-----
 src/XrdVoms/XrdVomsMapfile.hh |  27 +++++-
 2 files changed, 155 insertions(+), 22 deletions(-)

diff --git a/xrootd/src/XrdVoms/XrdVomsMapfile.cc b/xrootd/src/XrdVoms/XrdVomsMapfile.cc
index 98849fa48..aa4fef6d9 100644
--- a/xrootd/src/XrdVoms/XrdVomsMapfile.cc
+++ b/xrootd/src/XrdVoms/XrdVomsMapfile.cc
@@ -31,14 +31,16 @@
 #include "XrdSec/XrdSecEntity.hh"
 #include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdSys/XrdSysError.hh"
+#include "XrdSys/XrdSysFD.hh"
+#include "XrdSys/XrdSysPthread.hh"
 
 #include <memory>
 #include <fstream>
 #include <sstream>
 #include <vector>
 #include <string>
 #include <fcntl.h>
-
+#include <sys/poll.h>
 
 bool XrdVomsMapfile::tried_configure = false;
 std::unique_ptr<XrdVomsMapfile> XrdVomsMapfile::mapper;
@@ -57,14 +59,75 @@ PathToString(const std::vector<std::string> &path)
     return ss.str();
 }
 
+uint64_t monotonic_time_s() {
+  struct timespec tp;
+  clock_gettime(CLOCK_MONOTONIC, &tp);
+  return tp.tv_sec + (tp.tv_nsec >= 500000000);
+}
+
 }
 
 
 XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms,
     const std::string &mapfile)
     : m_mapfile(mapfile), m_xrdvoms(xrdvoms), m_edest(erp)
 {
-    m_last_update.store(0, std::memory_order_relaxed);
+    // Setup communication pipes; we write one byte to the child to tell it to shutdown;
+    // it'll write one byte back to acknowledge before our destructor exits.
+    int pipes[2];
+    if (-1 == XrdSysFD_Pipe(pipes)) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
+        return;
+    }
+    if (-1 == XrdSysFD_Pipe(pipes)) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
+        return;
+    }
+
+    struct stat statbuf;
+    if (-1 == stat(m_mapfile.c_str(), &statbuf)) {
+        m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile", m_mapfile.c_str());
+        return;
+    }
+    memcpy(&m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(m_mapfile_ctime)));
+
+    if (!ParseMapfile(m_mapfile)) {return;}
+
+    m_maintenance_pipe_r = pipes[0];
+    m_maintenance_pipe_w = pipes[1];
+    m_maintenance_thread_pipe_r = pipes[0];
+    m_maintenance_thread_pipe_w = pipes[1];
+
+    pthread_t tid;
+    auto rc = XrdSysThread::Run(&tid, XrdVomsMapfile::MaintenanceThread,
+                                static_cast<void*>(this), 0, "VOMS Mapfile refresh");
+    if (rc) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to launch VOMS mapfile monitoring thread");
+        close(m_maintenance_pipe_r); m_maintenance_pipe_r = -1;
+        close(m_maintenance_pipe_w); m_maintenance_pipe_w = -1;
+        close(m_maintenance_thread_pipe_r); m_maintenance_thread_pipe_r = -1;
+        close(m_maintenance_thread_pipe_w); m_maintenance_thread_pipe_w = -1;
+        return;
+    }
+    m_is_valid = true;
+}
+
+
+XrdVomsMapfile::~XrdVomsMapfile()
+{
+    char indicator[1];
+    if (m_maintenance_pipe_w >= 0) {
+        indicator[0] = '1';
+        int rval;
+        do {rval = write(m_maintenance_pipe_w, indicator, 1);} while (rval != -1 || errno == EINTR);
+        if (m_maintenance_thread_pipe_r >= 0) {
+            do {rval = read(m_maintenance_thread_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
+            close(m_maintenance_thread_pipe_r);
+            close(m_maintenance_thread_pipe_w);
+        }
+        close(m_maintenance_pipe_r);
+        close(m_maintenance_pipe_w);
+    }
 }
 
 
@@ -91,21 +154,6 @@ XrdVomsMapfile::ParseMapfile(const std::string &mapfile)
 }
 
 
-bool
-XrdVomsMapfile::Reconfigure() {
-    auto now = time(NULL);
-    auto retval = true;
-    std::stringstream ss;
-    ss << "Last update " << m_last_update.load(std::memory_order_relaxed) << ", " << now;
-    m_edest->Log(LogMask::Debug, "VOMS Mapfile", ss.str().c_str());
-    if (now > m_last_update.load(std::memory_order_relaxed) + 30) {
-        retval = ParseMapfile(m_mapfile);
-        m_last_update.store(now, std::memory_order_relaxed);
-    }
-    return retval;
-}
-
-
 bool
 XrdVomsMapfile::ParseLine(const std::string &line, std::vector<std::string> &entry, std::string &target)
 {
@@ -255,8 +303,6 @@ XrdVomsMapfile::GetSecData(XrdLink * lnk, XrdSecEntity &entity, SSL *ssl)
 int
 XrdVomsMapfile::Apply(XrdSecEntity &entity)
 {
-    Reconfigure();
-
     // In current use cases, the gridmap results take precedence over the voms-mapfile
     // results.  However, the grid mapfile plugins often will populate the name attribute
     // with a reasonable default (DN or DN hash) if the mapping fails, meaning we can't
@@ -367,8 +413,70 @@ XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
     if (!map_filename.empty()) {
         if (erp) erp->Emsg("Config", "Will initialize VOMS mapfile", map_filename.c_str());
         mapper.reset(new XrdVomsMapfile(erp, xtractor, map_filename));
-        mapper->Reconfigure();
     }
 
-    return mapper.get();
+    return mapper->IsValid() ? mapper.get() : nullptr;
+}
+
+
+void *
+XrdVomsMapfile::MaintenanceThread(void *myself_raw)
+{
+    auto myself = static_cast<XrdVomsMapfile*>(myself_raw);
+
+   auto now = monotonic_time_s();
+   auto next_update = now + m_update_interval;
+   while (true) {
+       now = monotonic_time_s();
+       auto remaining = next_update - now;
+       struct pollfd fds;
+       fds.fd = myself->m_maintenance_pipe_r;
+       fds.events = POLLIN;
+       auto rval = poll(&fds, 1, remaining*1000);
+       if (rval == -1) {
+           if (rval == EINTR) continue;
+           else break;
+       } else if (rval == 0) { // timeout!  Let's run maintenance.
+           struct stat statbuf;
+           if (-1 == stat(myself->m_mapfile.c_str(), &statbuf)) {
+               myself->m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile",
+                   myself->m_mapfile.c_str());
+               next_update = monotonic_time_s() + m_update_interval_failure;
+               myself->m_mapfile_ctime.tv_sec = 0;
+               myself->m_mapfile_ctime.tv_nsec = 0;
+               myself->m_is_valid = false;
+               continue;
+           }
+           if ((myself->m_mapfile_ctime.tv_sec == statbuf.st_ctim.tv_sec) &&
+               (myself->m_mapfile_ctime.tv_nsec == statbuf.st_ctim.tv_nsec))
+           {
+               myself->m_edest->Log(LogMask::Debug, "Maintenance", "Not reloading VOMS mapfile; "
+                   "no changes detected.");
+               next_update = monotonic_time_s() + m_update_interval;
+               continue;
+           }
+           memcpy(&myself->m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(statbuf.st_ctim)));
+
+           myself->m_edest->Log(LogMask::Debug, "Maintenance", "Reloading VOMS mapfile now");
+           if ( (myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
+               next_update = monotonic_time_s() + m_update_interval;
+           } else {
+               next_update = monotonic_time_s() + m_update_interval_failure;
+           }
+       } else { // FD ready; let's shutdown
+           if (fds.revents & POLLIN) {
+               char indicator[1];
+               do {rval = read(myself->m_maintenance_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
+           }
+       }
+   }
+   if (errno) {
+       myself->m_edest->Emsg("Maintenance", "Failed to poll for events from parent object");
+   }
+   char indicator = '1';
+   int rval;
+   do {rval = write(myself->m_maintenance_thread_pipe_w, &indicator, 1);} while (rval != -1 || errno == EINTR);
+
+
+   return nullptr;
 }
diff --git a/xrootd/src/XrdVoms/XrdVomsMapfile.hh b/xrootd/src/XrdVoms/XrdVomsMapfile.hh
index 7273f0b33..61c47cbfe 100644
--- a/xrootd/src/XrdVoms/XrdVomsMapfile.hh
+++ b/xrootd/src/XrdVoms/XrdVomsMapfile.hh
@@ -35,12 +35,16 @@
 class XrdVomsMapfile : public XrdHttpSecXtractor {
 
 public:
+    virtual ~XrdVomsMapfile();
+
     static XrdVomsMapfile *Configure(XrdSysError *, XrdHttpSecXtractor *);
     static XrdVomsMapfile *Get();
 
     virtual int GetSecData(XrdLink *, XrdSecEntity &, SSL *);
     int Apply(XrdSecEntity &);
 
+    bool IsValid() const {return m_is_valid;}
+
     /* Base class returns an error if these aren't overridden */
     virtual int Init(SSL_CTX *, int) {return 0;}
     virtual int InitSSL(SSL *ssl, char *cadir) {return 0;}
@@ -73,14 +77,35 @@ class XrdVomsMapfile : public XrdHttpSecXtractor {
     bool Compare(const MapfileEntry &entry, const std::vector<std::string> &fqan);
     std::vector<std::string> MakePath(const XrdOucString &group);
 
+    // A continuously-running thread for maintenance tasks (reloading the mapfile)
+    static void *MaintenanceThread(void *myself_raw);
+
+    // Set to true if the last maintenance attempt succeeded.
+    bool m_is_valid = false;
+    // Time of the last observed status change of file.
+    struct timespec m_mapfile_ctime{0, 0};
+
     std::string m_mapfile;
     std::shared_ptr<const std::vector<MapfileEntry>> m_entries;
     XrdHttpSecXtractor *m_xrdvoms{nullptr};
     XrdSysError *m_edest{nullptr};
 
-    std::atomic<time_t> m_last_update;
+    // Pipes to allow the main thread to communicate shutdown events to the maintenance
+    // thread, allowing for a clean shutdown.
+    int m_maintenance_pipe_r{-1};
+    int m_maintenance_pipe_w{-1};
+    int m_maintenance_thread_pipe_r{-1};
+    int m_maintenance_thread_pipe_w{-1};
+
+        // After success, how long to wait until the next mapfile check.
+    static constexpr unsigned m_update_interval = 30;
+        // After failure, how long to wait until the next mapfile check.
+    static constexpr unsigned m_update_interval_failure = 3;
 
     // Singleton
     static std::unique_ptr<XrdVomsMapfile> mapper;
+    // There are multiple protocol objects that may need the mapfile object;
+    // if we already tried-and-failed configuration once, this singleton will
+    // help us avoid failing again.
     static bool tried_configure;
 };
-- 
2.25.1

