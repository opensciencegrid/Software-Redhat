From 74905b6014dac58abc9a98b249fa7191d6cd8567 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Tue, 4 Jan 2022 07:49:08 -0600
Subject: [PATCH 03/17] Add max file open tracking.

This tracks the maximum number of files open per "entity" (which might
be distinct from the login name in case of tokens); once the file limit
is hit, the code returns an error instead of opening a new file.

Code is only active when throttle module is loaded and max is explicitly
set.  Here's an example configuration with a ridiculously low max (which
is useful for testing, of course):

```
throttle.max_open_files 2
xrootd.fslib ++ throttle
throttle.trace debug files
```

(cherry picked from commit 92ff8826ec29dc20abf75eddb0075ebfe2d82018)
---
 src/XrdThrottle/XrdThrottle.hh                |  4 ++
 src/XrdThrottle/XrdThrottleFile.cc            | 19 ++++---
 .../XrdThrottleFileSystemConfig.cc            | 28 ++++++++++
 src/XrdThrottle/XrdThrottleManager.cc         | 53 +++++++++++++++++++
 src/XrdThrottle/XrdThrottleManager.hh         | 12 +++++
 src/XrdThrottle/XrdThrottleTrace.hh           |  1 +
 6 files changed, 110 insertions(+), 7 deletions(-)

diff --git a/xrootd/src/XrdThrottle/XrdThrottle.hh b/xrootd/src/XrdThrottle/XrdThrottle.hh
index 64856f351..258d84983 100644
--- a/xrootd/src/XrdThrottle/XrdThrottle.hh
+++ b/xrootd/src/XrdThrottle/XrdThrottle.hh
@@ -125,6 +125,7 @@ friend class FileSystem;
    unique_sfs_ptr m_sfs;
    int m_uid; // A unique identifier for this user; has no meaning except for the fairshare.
    std::string m_loadshed;
+   std::string m_connection_id; // Identity for the connection; may or may authenticated
    std::string m_user;
    XrdThrottleManager &m_throttle;
    XrdSysError &m_eroute;
@@ -281,6 +282,9 @@ friend XrdSfsFileSystem * XrdSfsGetFileSystem_Internal(XrdSfsFileSystem *, XrdSy
    int
    xtrace(XrdOucStream &Config);
 
+   int
+   xmaxopen(XrdOucStream &Config);
+
    static FileSystem  *m_instance;
    XrdSysError         m_eroute;
    XrdOucTrace         m_trace;
diff --git a/xrootd/src/XrdThrottle/XrdThrottleFile.cc b/xrootd/src/XrdThrottle/XrdThrottleFile.cc
index 89213faab..35e8e0997 100644
--- a/xrootd/src/XrdThrottle/XrdThrottleFile.cc
+++ b/xrootd/src/XrdThrottle/XrdThrottleFile.cc
@@ -12,7 +12,7 @@ using namespace XrdThrottle;
    unsigned port; \
    std::string host; \
    m_throttle.PerformLoadShed(m_loadshed, host, port); \
-   m_eroute.Emsg("File", "Performing load-shed for client", m_user.c_str()); \
+   m_eroute.Emsg("File", "Performing load-shed for client", m_connection_id.c_str()); \
    error.setErrInfo(port, host.c_str()); \
    return SFS_REDIRECT; \
 }
@@ -33,7 +33,7 @@ File::File(const char                     *user,
      m_sfs(sfs),
 #endif
      m_uid(0),
-     m_user(user ? user : ""),
+     m_connection_id(user ? user : ""),
      m_throttle(throttle),
      m_eroute(eroute)
 {}
@@ -50,20 +50,25 @@ File::open(const char                *fileName,
 {
    // Try various potential "names" associated with the request, from the most
    // specific to most generic.
-   std::string unique_name;
-   if (client->eaAPI && client->eaAPI->Get("token.subject", unique_name)) {
-       if (client->vorg) unique_name += client->vorg;
+   if (client->eaAPI && client->eaAPI->Get("token.subject", m_user)) {
+       if (client->vorg) m_user = std::string(client->vorg) + ":" + m_user;
    } else if (client->eaAPI) {
-       client->eaAPI->Get("request.name", unique_name);
+       client->eaAPI->Get("request.name", m_user);
    }
-   m_uid = XrdThrottleManager::GetUid(unique_name.empty() ? client->name : unique_name.c_str());
+   if (m_user.empty()) {m_user = client->name ? client->name : "nobody";}
+   m_uid = XrdThrottleManager::GetUid(m_user.c_str());
    m_throttle.PrepLoadShed(opaque, m_loadshed);
+   if (!m_throttle.OpenFile(m_user)) {
+       error.setErrInfo(EMFILE, "User has hit their maximum file limit at the server.");
+       return SFS_ERROR;
+   }
    return m_sfs->open(fileName, openMode, createMode, client, opaque);
 }
 
 int
 File::close()
 {
+   m_throttle.CloseFile(m_user);
    return m_sfs->close();
 }
 
diff --git a/xrootd/src/XrdThrottle/XrdThrottleFileSystemConfig.cc b/xrootd/src/XrdThrottle/XrdThrottleFileSystemConfig.cc
index e2a28e3e0..3eea8a9ba 100644
--- a/xrootd/src/XrdThrottle/XrdThrottleFileSystemConfig.cc
+++ b/xrootd/src/XrdThrottle/XrdThrottleFileSystemConfig.cc
@@ -147,6 +147,7 @@ FileSystem::Configure(XrdSysError & log, XrdSfsFileSystem *native_fs)
          if (!val || !val[0]) {log.Emsg("Config", "fslib not specified."); continue;}
          fslib = val;
       }
+      TS_Xeq("throttle.max_open_files", xmaxopen);
       TS_Xeq("throttle.throttle", xthrottle);
       TS_Xeq("throttle.loadshed", xloadshed);
       TS_Xeq("throttle.trace", xtrace);
@@ -166,6 +167,32 @@ FileSystem::Configure(XrdSysError & log, XrdSfsFileSystem *native_fs)
    return 0;
 }
 
+/******************************************************************************/
+/*                            x m a x o p e n                                 */
+/******************************************************************************/
+
+/* Function: xmaxopen
+
+   Purpose:  Parse the directive: throttle.max_open_files <limit>
+
+             <limit>   maximum number of open file handles for a unique entity.
+
+  Output: 0 upon success or !0 upon failure.
+*/
+int
+FileSystem::xmaxopen(XrdOucStream &Config)
+{
+    auto val = Config.GetWord();
+    if (!val || val[0] == '\0')
+       {m_eroute.Emsg("Config", "Max open files not specified!  Example usage: throttle.max_open_files 16000");}
+    long long max_open = -1;
+    if (XrdOuca2x::a2sz(m_eroute, "max open files value", val, &max_open, 1)) return 1;
+
+    m_throttle.SetMaxOpen(max_open);
+    return 0;
+}
+
+
 /******************************************************************************/
 /*                            x t h r o t t l e                               */
 /******************************************************************************/
@@ -306,6 +333,7 @@ int FileSystem::xtrace(XrdOucStream &Config)
       {"iops",      TRACE_IOPS},
       {"bandwidth", TRACE_BANDWIDTH},
       {"ioload",    TRACE_IOLOAD},
+      {"files",     TRACE_FILES},
    };
    int i, neg, trval = 0, numopts = sizeof(tropts)/sizeof(struct traceopts);
 
diff --git a/xrootd/src/XrdThrottle/XrdThrottleManager.cc b/xrootd/src/XrdThrottle/XrdThrottleManager.cc
index b735f624f..14635b885 100644
--- a/xrootd/src/XrdThrottle/XrdThrottleManager.cc
+++ b/xrootd/src/XrdThrottle/XrdThrottleManager.cc
@@ -104,6 +104,59 @@ XrdThrottleManager::StealShares(int uid, int &reqsize, int &reqops)
    TRACE(IOPS, "After stealing shares, " << reqops << " of request ops remain.");
 }
 
+/*
+ * Increment the number of files held open by a given entity.  Returns false
+ * if the user is at the maximum; in this case, the internal counter is not
+ * incremented.
+ */
+bool
+XrdThrottleManager::OpenFile(const std::string &entity)
+{
+    if (m_max_open == 0) return true;
+
+    const std::lock_guard<std::mutex> lock(m_file_mutex);
+    auto iter = m_file_counters.find(entity);
+    if (iter == m_file_counters.end()) {
+        m_file_counters[entity] = 1;
+        TRACE(FILES, "User " << entity << " has opened their first file");
+    } else if (iter->second < m_max_open) {
+        iter->second++;
+        TRACE(FILES, "User " << entity << " has " << iter->second << " open files");
+    } else {
+        TRACE(FILES, "User " << entity << " has hit the limit of " << iter->second << " open files");
+        return false;
+    }
+    return true;
+}
+
+
+/*
+ * Decrement the number of files held open by a given entity.
+ *
+ * Returns false if the value would have fallen below zero or
+ * if the entity isn't tracked.
+ */
+bool
+XrdThrottleManager::CloseFile(const std::string &entity)
+{
+    if (m_max_open == 0) return true;
+
+    const std::lock_guard<std::mutex> lock(m_file_mutex);
+    auto iter = m_file_counters.find(entity);
+    if (iter == m_file_counters.end()) {
+        TRACE(FILES, "WARNING: User " << entity << " closed a file but throttle plugin never saw an open file");
+        return false;
+    } else if (iter->second == 0) {
+        TRACE(FILES, "WARNING: User " << entity << " closed a file but throttle plugin thinks all files were already closed");
+        return false;
+    } else {
+        iter->second--;
+    }
+    TRACE(FILES, "User " << entity << " closed a file; " << iter->second << " remain open");
+    return true;
+}
+
+
 /*
  * Apply the throttle.  If there are no limits set, returns immediately.  Otherwise,
  * this applies the limits as best possible, stalling the thread if necessary.
diff --git a/xrootd/src/XrdThrottle/XrdThrottleManager.hh b/xrootd/src/XrdThrottle/XrdThrottleManager.hh
index 2a307cc3d..8e82e2203 100644
--- a/xrootd/src/XrdThrottle/XrdThrottleManager.hh
+++ b/xrootd/src/XrdThrottle/XrdThrottleManager.hh
@@ -31,6 +31,8 @@
 #include <string>
 #include <vector>
 #include <ctime>
+#include <mutex>
+#include <unordered_map>
 
 #include "XrdSys/XrdSysPthread.hh"
 
@@ -47,17 +49,22 @@ friend class XrdThrottleTimer;
 
 void        Init();
 
+bool        OpenFile(const std::string &entity);
+bool        CloseFile(const std::string &entity);
+
 void        Apply(int reqsize, int reqops, int uid);
 
 bool        IsThrottling() {return (m_ops_per_second > 0) || (m_bytes_per_second > 0);}
 
 void        SetThrottles(float reqbyterate, float reqoprate, int concurrency, float interval_length)
             {m_interval_length_seconds = interval_length; m_bytes_per_second = reqbyterate;
              m_ops_per_second = reqoprate; m_concurrency_limit = concurrency;}
 
 void        SetLoadShed(std::string &hostname, unsigned port, unsigned frequency)
             {m_loadshed_host = hostname; m_loadshed_port = port; m_loadshed_frequency = frequency;}
 
+void        SetMaxOpen(unsigned long max_open) {m_max_open = max_open;}
+
 //int         Stats(char *buff, int blen, int do_sync=0) {return m_pool.Stats(buff, blen, do_sync);}
 
 static
@@ -127,6 +134,11 @@ unsigned m_loadshed_port;
 unsigned m_loadshed_frequency;
 int m_loadshed_limit_hit;
 
+// Maximum number of open files
+unsigned long m_max_open{0};
+std::unordered_map<std::string, unsigned long> m_file_counters;
+std::mutex m_file_mutex;
+
 static const char *TraceID;
 
 };
diff --git a/xrootd/src/XrdThrottle/XrdThrottleTrace.hh b/xrootd/src/XrdThrottle/XrdThrottleTrace.hh
index e601bc949..71e465088 100644
--- a/xrootd/src/XrdThrottle/XrdThrottleTrace.hh
+++ b/xrootd/src/XrdThrottle/XrdThrottleTrace.hh
@@ -10,6 +10,7 @@
 #define TRACE_IOPS      0x0002
 #define TRACE_IOLOAD    0x0004
 #define TRACE_DEBUG     0x0008
+#define TRACE_FILES     0x0010
 
 #ifndef NODEBUG
 
-- 
2.25.1

